1. 시간복잡도와 공간복잡도
보통 위 두 가지 개념은 알고리즘에 관해 공부를 할 때 들어볼 수 있는 단어이다. 
시간복잡도란 알고리즘의 수행시간의 분석 결과, 공간 복잡도는 알고리즘의 메모리 사용량에 대한 분석 결과이다.
시간복잡도를 계산 할 때 보통 경우를 3가지로 나눠서 계산을 한다. Best case, Worst Case, Average Case
계산을 한 결과를 표현하는 방법으로는 Big O 표기법이 있는데, O(1) O(logn) O(n) O(nlogn) O(n^2) O(n^3) O(2^n) O(n!)
위 순서로 n이 커질수록 처리해야하는 데이터가 많아져 시간이 오래걸리게 된다.

공간 복잡도 계산의 경우 매우 간단하다. 메모리를 얼마나 사용했는지를 계산하면 된다. 크기가 n인 배열을 입력했을 때,
알고리즘이 내부에서 n*n의 이차원 배열을 생성한다면 이 알고리즘의 공간복잡도는 n^2이 된다.
보통 공간복잡도는 시간복잡도에 비해 중요하지 않게 생각되는 경우가 많다. 그러나 빅데이터를 처리하는 겅우에는 공간복잡도가 커지게 되는 경우
메모리에 한번에 올라가지 않아 실행이 되지 않는 문제가 발생 할 수도 있다. 이러한 경우에는 데이터를 나눠서 처리하고 나중에 병합하는 방식으로 처리한다.

2. 스택과 큐
스택은 후입선출 구조로 나중에 들어온 데이터가 먼저 나가게 된다. 그러므로 top에는 가장 나중에 들어온 데이터를 가리키고 있다.
삽입을 하는 연산을 push 삭제를 하는 연산은 pop라고 한다. 
여기서 비어있는 스택에서 pop를 실행하면 stack underflow가 발생하며, 정해진 스택용량를 초과해서 push를 하는 경우에는 stack overflow가 발생한다.

큐는 스택과 다르게 선입선출 구조로, 먼저 들어온 데이터가 제일 먼저 나가는 구조이다. 
스택은 top을 통해서 삭제와 삽입이 이루어지지만, 큐는 한쪽에서는 삽입 다른 한쪽에서는 삭제가 이루어진다.
삭제연산만 수행되는 곳은 front 삽입이 이루어지는 곳은 rear라고 한다. 
큐에서의 삽입연산은 enQueue 삭제연산은 deQueue라고 한다.

3. 배열과 연결리스트
배열은 입력된 데이터들이 메모리 공간에서 연속적으로 저장되어 있는 구조이다. 연속적으로 저장이 되어 있기 때문에 index를 통한 접근이 용이하다.
배열의 시간복잡도는 탐색의 경우 접근하고자 하는 인덱스를 알고 있는 경우 O(1), 순차탐색시에는 O(n)
삽입과 삭제는 중간에 삽입과 삭제를 하는 경우 O(n), 끝에서 삽입과 삭제를 하는 경우에는 O(1)

연결리스트는 여러 개의 노드들이 순차적으로 연결된 형태를 갖는 구조이다. 첫번째 노드를 헤드, 마지막 노드를 테일이라고 한다.
각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어져 있다. 배열과는 다르게 연속적으로 메모리를 사용하지 않는다.
배열과는 다르게 순차적으로 접근해야하는 경우 불리할 수도 있으나, 삽입과 삭제에서는 용이하다.
연결리스트의 시간복잡도는 탐색에서는 O(n) 삽입과 삭제의 경우에는 O(1)

두 가지를 비교하면 배열의 장점은 인덱스를 통한 빠른 접근 가능, 연결리스트는 삽입과 삭제가 용이
단점은 배열의 경우, 삽입/삭제가 오래걸림, 배열 중간에 있는 데이터가 삭제되는 경우 공간의 낭비가 발생
연결리스트는 임의 접근이 불가능, 처음부터 탐색을 진행해야 한다.

4. 트랜잭션과 acid
트랜잭션은 query를 하나의 묶음 처리해서 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 rollback, 오류없이 실행을 마치면 commit을 하는 
실행단위를 의미한다.
즉, 한 번의 질의가 실행되면 모두 수행되거나, 모두 수행되지 않는 작업수행의 논리적인 단위이다.
이를 사용하는 이유는 데이터의 부정합을 방지하고 함이다. 부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만
처리하도록 하면 되는데, 이는 효율이 너무 떨어진다. 
즉, 병렬로 처리할 수 밖에 없는 상황에서 부정합을 방지하고자 트랜잭션을 사용하는 것이다.

원자성: 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것을 의미, 작업 단위를 일부분만 실행하지 않는다는 것을 의미
일관성: 트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것을 의미, 트랜잭션이 수행되지 전에 데이터의 타입이 정수형이었는데, 수행되고 나서
문자열이 되지 않는 것을 의미한다
격리성: 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것, 서로 간섭이 불가능하다.
지속성: 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 의미, commit을 하면 현재 상태는 영원히 보장되는 것을 의미한다.

5. 정규화의 개념 및 장단점
정규화는 이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정이다. 분해를 하면 여러 개의 릴레이션을 생성하게 된다. 
이를 단계별로 구분하여 정규형이 높아질수록 이상현상은 줄어들게 된다.

제 1정규형: 도메인의 원자성, 각 컬럼이 하나의 속성만을 가져야 한다.
제 2정규형: 부분 함수적 종속 제거, 모든 컬럼이 완전 함수 종속을 만족해야 한다.
제 3정규형: 이행 함수적 종속 제거, 기본키를 제외한 속성들 간의 이행 종속성이 없어야 한다.
BCNF: 후보 키가 아닌 결정자 제거, 모든 결정자가 후보키 집합에 속해야 한다.
제 4정규형: 다치 종속이 없어야 한다. 다중값 종속을 제거하는 과정을 의미한다
제 5정규형: 조인 종속이 없어야 한다. 조인 연산을 수행 시 손실이 없어야 한다.

장점은 데이터베이스 변경 시 이상현산을 제거할 수 있다.
정규화된 DB에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
DB와 연동된 프로그램에 최소한의 영향만을 미치게 되어 프로그램의 생명을 연장시킨다.

단점은 여러 개의 릴레이션으로 분리된 경우 서로간의 JOIN연산이 많아진다.
질의에 대한 응답 시간이 느려질 수도 있다. 만약 JOIN이 많이 발생하여 성능의 저하가 나타나면 반정규화를 적용할 수 있다.

6.CORS란??

Cross Origin Resource Sharing의 약자로 교차 출처 자원 공유라는 뜻을 가진다. 여기서 origin은 URL에서 프로토콜과 도메인 포트번호를 다 합친 부분을 의미한다.
CORS의 동작원리는 브라우저가 다른 출처로 요청을 보낼 때, origin헤더에 자신의 origin을 설정하고, 서버로부터 응답을 받으면 응답의 Access-Control-Allow-Origin 헤더에 설정된
Origin의 목록에 요청의 Origin 헤더 값이 포함이 되는지 검사를 하게 된다.

7. var, let, const
var 문법은 예전 문법인 ES5에서 사용하던 변수 선언 방식이다. var는 재할당과 재선언이 가능하다. 그래서 코드가 길어져 위에서 선언된 변수를 
밑에서 또 재선언하고 재할당해서 사용을 한다면 우리는 예상치 못한 문제를 맞이할 수 있다.

위와 같은 문제를 방지하고자 생긴 것이 let과 const이다.
우선 let은 재할당은 가능하지만 재선언은 불가능하다. 위에서 let name = "철수"라 선언과 할당을 하고
밑에서 name = "유리"라 하는 것은 가능하지만, let name = "훈이" 이렇게 사용하는 것은 불가능하다.

const는 재할당 재선언 둘 다 불가능하다. 위에서 했던 것처럼 const name = "철수"라 하고 밑에서
name = "유리"라고 하는 것이 불가능하다.

8. promise
프로미스가 생성된 시점에는 알려지지 않을 수도 있는 값을 위한 대리자로, 비동기 연산이 종료된 이후에 결과 값과 실패 사유를 위한 처리기를 연결할 수 있다.(then, catch)
프로미스를 사용하면 비동기 메서드를 마치 동기 메서드처럼 값을 반환할 수 있다.

프로미스는 세가지의 상태를 가지는데, 대기(pending), 이행(fulfilled), 거부(rejected)가 있다. 
대기상태인 프로미스는 이행이 될 수도 있고, 거부될 수도 있는 상태를 가리킨다.

9.hoisting
함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 의미한다.
자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 모두 모아서 유효 범위 최상단에 선언을 한다. 여기서 유효범위는 함수의 블록 스코프를 의미한다.
즉 함수 내에서 아래쪽에 존재하는 내용 중 필요한 값들을 끌어올리는 것이다. 실제로 코드가 끌어 올려지는 것은 아니고, 자바스크립트 인터프리터가 내부적으로 끌어올려서 처리를 한다.

호이스팅의 대상은 var 변수와 함수 선언문이 해당된다. let,const 함수표현식는 대상이 아니다.

11. async 와 await를 설명해주세요요
async 와 await는 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법입니다. 기존의 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와줍니다.

사용방법은 async는 함수앞에 await는 비동기 처리 메서드 앞에 붙여서 사용을 합니다.
ex)  async function test(){
	await db.find()
}
await의 대상은 프로미스를 반환하는 함수들입니다.

async와 await의 예외를 처리하는 방법은 try catch입니다. 프로미스에서 .catch()를 사용했던 것처럼 async에서는 catch{}를 사용하면 됩니다.

12. arrow function에 대해 설명해주세요
ES6문법에서 새롭게 추가된 함수를 정의하는 방법이다.
ex) let a = (num) => {
   let b = num
   return b
}
함수 내부의 내용이 return만 있다면 중괄호와 return을 생략할 수 있다.
ex)  let a = () => new Date()
매개변수가 없을 경우에는 괄호가 필수이고, return 할 값이 객체일 경우에는 괄호가 필수이다.

화살표 함수는 기존 함수의 기능을 문법적으로 편하게 직관적으로 보여지기 위해 만들어진 이유보다 함수를 가볍게 사용하기 위함이 더 큽니다.
함수를 실행하는 순간 함수의 덩어리에 대한 데이터를 모두 들고 컨텍스트를 생성하고 하는 등등의 내부에서 하는 일들이 많아서 무거웠으나, 지금 우리가 무리없이 사용가능한 이유는 컴퓨터의 성능이 향상되었기 때문입니다. 하지만 더 이상 함수의 성능적 이슈를 방치할 수 없어서 좀더 가벼운 함수를 만들고자 화살표 함수가 나타나게 된 것입니다.
이렇게 변화된 것 중의 하나가 this 바인딩이다.
화살표 함수는 함수 스코프를 생성하기 때문에 실행 컨텍스트 생성시 this를 바인딩하지 않는다.

13. == ===의 차이
둘의 주된 차이는 숫자를 숫자 리터럴과 비교하면 ==은 허용을 하지만, ===은 허용하지 않는다. ===은 값뿐만이 아니라 두 변수의 유형까지 확인하므로 허용을 하지 않는 것이다.
즉 ===은 false를 반환 ==는 true를 반환하게 된다.
ex) 0 == “0”은 true   0 === “0” false
      0 == [] true  0 === [] false

null과 undefined를 비교하면 ==은 참을 반환 === 거짓을 반환한다. null의 타입은 object이고
undefined는 undefined이기 때문이다.

14. 즐겨 보는 테크 유튜버나 뉴스레터가 있다면 알려주실 수 있을까요?
즐겨보진 않지만, 필요할 때 검색해서 보는 유튜버는 잇섭입니다.

15 .Express란 무엇이고 왜 필요하며 대안은 무엇이 있는지 설명해주실 수 있을까요?

익스프레스는 노드 상에서 동작하는 웹 개발 프레임워크이다.

쉽게 말하면 노드를 사용해 쉽게 서버를 구성할 수 있게 만든 라이브러리이다.
익스프레스는 가볍고 유연하게 웹 프레임워크를 구성할 수 있다는 장점이 있다. 이것은 
미들웨어 때문에 가능한 것인데, 자바스크립트 코드로 작성된 다양한 기능의 미들웨어는 개발자가 필요한 것만 선택하여 익스프레스와 결합해 사용할 수 있다.

미들웨어는 요청에 대한 응답 과정 중간에 끼어서 어떠한 동작을 수행해주는 역할을 한다.
응답을 보내주기 전에 미들웨어에서 지정한 동작을 수행하게 된다.

라우팅은 요청에 따라 어플리케이션이 응답하는 방법을 결정하는 것이다. 익스프레스에서 라우팅이 편리하며 직관적이다.

대안으로는 fastify가 있는데, 두 개의 차이점은 익스프레스는 안정성이 검증된 안정적인 프레임워크이고 패스티파이는 높은 퍼포먼스를 가진다는 차이가 있다.
